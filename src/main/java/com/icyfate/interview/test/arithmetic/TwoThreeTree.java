package com.icyfate.interview.test.arithmetic;

/**
 * 2-3树：红黑树前身，解决了BST树退化线性结构的问题，也避免了AVL树平衡操作太多带来的性能降低问题
 *
 *      1.可以为空树，不为空树的话，节点分为2-node和3-node
 *      2.2-node有一个键值key，和2个子节点，左子节点的值都小于key，右子节点的值都大于key
 *      3.3-node有二个key值，key1（左边的值） 和 key2（右边的值），和3个子节点，左子节点的值都小于key1，中子节点的值大于key1，
 *          小于key2，右子节点的值都大于key2
 *
 *  2-3树所有叶子节点深度相同，为了后面解释红黑树，这里认为其叶子节点的子节点为空节点（null links）
 *
 *  2-3树查找：和BST树基本相同，循环从根节点开始比较，如果查找值小于当前节点，继续和当前节点的左子节点比较，直至有一个节点值和查找值
 *              相等，或者到最后一层也没有相等的节点值。不同点是2-3树，3-node有2个值要多比较一次。
 *
 *  2-3树插入：
 *          大部分人都是按插入节点的4种类型：
 *              1. 2-node 直接插入
 *              2. 3-node，并且无父节点
 *              3. 3-node，并且父节点是2-node
 *              4. 3-node，并且父节点是3-node
 *
 *          个人感觉没必要，按2种类型就行
 *              1. 2-node  直接插入
 *              2. 3-node，临时变为4-node，把中间的元素推到上一层，如果没有上层，成为独立节点；有父节点的话，相等于，父节点插入。
 *                      执行父节点插入规则就可以了
 *
 *  2-3树删除：
 *          1.叶子节点
 *              1）叶子节点为3-node 直接删除，比较简单
 *              2）叶子节点为2-node
 *                      兄弟节点为3-node：借兄弟一个最近节点到删除节点位置，然后交换借调节点和父节点位置
 *                      兄弟节点为2-node：
 *                          父节点为3-node：无兄弟节点可借，父节点降到下一层和兄弟节点合并
 *                          父节点为2-node：中心思想，把兄弟节点节点变为3-node（通过不断的替换前驱或者后继节点），合并兄弟节点
 *                                          和其前驱（后继）节点，如果其前驱（后继节点）位置继续由前驱（后继）节点替换。
 *
 *          2.非叶子节点：把节点和前驱节点（或者后继节点交换），就变成了删除叶子节点的情况。
 *              前驱节点：该节点左子树的最右（大）节点
 *              后继节点：该节点右子树的最左（小）节点
 *
 *  满二叉树的情况：满二叉树要特殊处理，随便删除一个节点都会导出树高度减一，循环叶子节点合并上推
 *
 * @author sunbing
 * @version 1.0
 * @since 2021/11/17 16:04
 */
public class TwoThreeTree {

}
